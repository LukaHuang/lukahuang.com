<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.7">Jekyll</generator><link href="https://lukahuang.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://lukahuang.com/" rel="alternate" type="text/html" /><updated>2021-10-08T15:24:16+00:00</updated><id>https://lukahuang.com/feed.xml</id><title type="html">LukaHuang.com</title><subtitle>a Ruby Lover</subtitle><author><name>Luka Huang</name><email>codingluka@gmail.com</email></author><entry><title type="html">ArgoCD - 透過 ArgoCD 認識 GitOps</title><link href="https://lukahuang.com/introduction-to-gitops-via-argocd/" rel="alternate" type="text/html" title="ArgoCD - 透過 ArgoCD 認識 GitOps" /><published>2020-09-21T20:50:00+00:00</published><updated>2020-09-21T20:50:00+00:00</updated><id>https://lukahuang.com/introduction-to-gitops-via-argocd</id><content type="html" xml:base="https://lukahuang.com/introduction-to-gitops-via-argocd/">&lt;h1 id=&quot;argocd--透過-argocd-認識-gitops&quot;&gt;ArgoCD — 透過 ArgoCD 認識 GitOps&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*4Ggl4UF7SjZk4qoapcDBnA.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;什麼是-gitops-&quot;&gt;什麼是 GitOps ?&lt;/h3&gt;

&lt;p&gt;兩年前初次聽到 GitOps 的時候，我想說是不是只要 Git tag 觸發一些部屬相關的事情，像是下了某個 tag，就會觸發某 Ansible 的工作，部屬某一台伺服器。很遺憾，完全不是我想的那樣。&lt;/p&gt;

&lt;p&gt;在最近實際將 GitOps 整合進開發流程的過程中，深入研究了一下 GitOps。對 GitOps 有了多一點的了解，趁這個機會來跟大家分享一下。&lt;/p&gt;

&lt;p&gt;GitOps 是 Weaveworks 提出的一種持續交付(CD)的概念，透過 Git 來聲明基礎設施(infrastructure)希望的狀態。什麼是聲明基礎設施希望的狀態？&lt;/p&gt;

&lt;h3 id=&quot;從聲明基礎設施希望的狀態談到-k8s&quot;&gt;從聲明基礎設施希望的狀態談到 K8S&lt;/h3&gt;

&lt;p&gt;說到聲明希望的狀態，這就要來了解一下屬於 Cloud Native 體系的 Kubernetes 了。&lt;/p&gt;

&lt;p&gt;因為 Kubernetes 是使用 yaml 檔來建立或是修改所擁有的 K8S 元件。例如你想把某個服務擴展從 3 個 pod 擴展到 5 個 pod。那麼你就會修改 yaml 檔裡面的數字。並使用 kubectl 來應用 yaml 檔案至所對應的 K8S 集群。&lt;/p&gt;

&lt;p&gt;簡單說就是 yaml 等於你目前的 K8S 系統狀態。歡迎來到 yaml 的世界！&lt;/p&gt;

&lt;h3 id=&quot;gitops-解決了哪些痛點&quot;&gt;GitOps 解決了哪些痛點？&lt;/h3&gt;

&lt;p&gt;當我們想要對 K8S 集群做出改變的時候，我們可以做什麼事情？可以直接下 kubectl apply 直接對 K8S 集群進行修改。可是這樣就出現了一個問題，當有許多人都想要對同一個 K8S 進行修改的時候。A 怎麼知道 B 做了什麼修改？如果 B 修改過後，A 並不知道 B 修改了什麼，也進行了一次修改。那麼很有造成系統全面癱瘓。&lt;/p&gt;

&lt;p&gt;Kubernetes 就像一個終極兵器，你可以讓他輕鬆的做到你想做的事情，例如：在幾分鐘內長出具有負載均衡能力的服務。但是也因此如果操作不當，後果會比傳統架構還要嚴重很多。&lt;/p&gt;

&lt;p&gt;這就是 GitOps 出現的原因！&lt;/p&gt;

&lt;h3 id=&quot;gitops-的原則&quot;&gt;GitOps 的原則&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*HHeZOMbdqCwuJ5GxiAkNQw.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Weaveworks 提出 GitOps 的概念，並使用 Flux (不是前端的Flux) 來實作之。其中有幾個比較重要的原則：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;整個系統必須是聲名式的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;希望的狀態必須用 Git 做版控&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 Git 中獲准(appoved)的改變可以自動應用到系統上&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;軟體代理(Agent)必須確保系統正確性，如果不正確的話需要有警報通知使用者。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;核心觀念其實就是讓你的系統具有「可觀測性」，你可以看到系統目前的狀態。並將所有對 K8S 做的操作，都透過 Git 來操作，這樣的話所有的操作過程都會是一個一個的 Commit。&lt;/p&gt;

&lt;p&gt;下圖左邊是希望的狀態，也就是 Git 中定義的狀態。而實際的狀態，則是右邊。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/NaN/1*IDeYMbyPP8-V-L456PRFHg.jpeg&quot; alt=&quot;[https://github.com/weaveworks/awesome-](https://github.com/weaveworks/awesome-gitops)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果我們使用的是 ArgoCD 可以輕鬆看到希望狀態與實際狀態的不同。&lt;/p&gt;

&lt;h3 id=&quot;用-argo-cd-來了解-gitops&quot;&gt;用 Argo CD 來了解 GitOps&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/NaN/1*TgJWIt9bE2UDgKLwlp2_hA.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ArogCD 是一款 GitOps 的實現。我們來看看上述說的 GitOps 原則到底是怎麼回事。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/NaN/1*rwgdphu1Aq59cG_stmrtRA.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;這是 Argo CD 的圖案，一支外太空章魚(還是什麼生物？)，他提供了強大的觀測介面。可以很好的觀測目前 Kubernetes 集群的狀態。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/NaN/1*8CA6GfxOSSb9t3FLRPUePA.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;來動手做做看！做一個小改變&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/NaN/1*j_vkc6z1D78bGRIYqttJxA.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Argo CD 顯示 Out of sync&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/NaN/1*lbeE9qAMq4OzWBpHDLcn2w.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;透過 ArgoCD 可以看到到底對 K8S 集群做了哪些改變。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/NaN/1*pkCl-99a3QdDNqLE1r02-w.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;手動按下 Sync&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/NaN/1*bCNQ2LDOOEoMKx_4TPra0A.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看看到底發生了什麼事&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/NaN/1*6J7atxk6ZSVwoArW31lAZA.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;並且部屬也有版控，萬一不幸弄壞，也可以即時回到上一版本。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/NaN/1*6I5lTwZkVhrYWXCYhSCqMQ.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用起來是不是很輕鬆寫意！&lt;/p&gt;

&lt;h3 id=&quot;心得&quot;&gt;心得&lt;/h3&gt;

&lt;p&gt;GitOps 提供 K8S 集群良好可觀測性，並且把開發或是運維對集群的操作記錄在 Git 中，讓任何人可以清楚看到集群做了哪些改變。並且提供了單一的出口，讓開發者和運惟人員不會私自的對集群改變。萬一被改變了，也提供了警報功能來通知主要運維人員。這樣的方式對於 K8S 日常維護來說，無疑是提供了一個非常實用且可靠的方案。&lt;/p&gt;

&lt;h3 id=&quot;同場加映&quot;&gt;同場加映&lt;/h3&gt;

&lt;p&gt;2021/5/11 update，本篇是 ArgoCD 入門，如果想要看看 ArgoCD 進階運用，請參閱小城老師的文章：
&lt;a href=&quot;https://medium.com/starbugs/argo-cd-applicationset-controller-%E4%B8%96%E7%95%8C%E7%82%BA%E6%88%91%E8%80%8C%E8%BD%89%E5%8B%95-a837f9392298&quot;&gt;&lt;strong&gt;Argo CD ApplicationSet Controller: 世界為我而轉動！&lt;/strong&gt;
&lt;em&gt;新推出的 Argo CD ApplicationSet Controller 讓使用者在單個 YAML 檔案內像是寫 For Loop 程式，隨需求一次性地建立大量的 Application CRD，就讓我們使用實際範例來看它如何解放…&lt;/em&gt;medium.com&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;參考資料&quot;&gt;參考資料&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.weave.works/technologies/gitops/&quot;&gt;Guide To GitOps&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.hwchiu.com/gitops.html&quot;&gt;淺談 GitOps 的概念&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Luka</name></author><category term="Kubernetes" /><summary type="html">ArgoCD — 透過 ArgoCD 認識 GitOps</summary></entry><entry><title type="html">從 Github 開源指南｜學習如何貢獻開源專案</title><link href="https://lukahuang.com/introduction-to-open-source-guild/" rel="alternate" type="text/html" title="從 Github 開源指南｜學習如何貢獻開源專案" /><published>2020-08-15T20:50:00+00:00</published><updated>2020-08-15T20:50:00+00:00</updated><id>https://lukahuang.com/introduction-to-open-source-guild</id><content type="html" xml:base="https://lukahuang.com/introduction-to-open-source-guild/">&lt;h1 id=&quot;從-github-開源指南學習如何貢獻開源專案&quot;&gt;從 Github 開源指南｜學習如何貢獻開源專案&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/7872/0*8Mqb8j7gMZ3_R-UI&quot; alt=&quot;Photo by [Tim Mossholder](https://unsplash.com/@timmossholder?utm_source=medium&amp;amp;utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&amp;amp;utm_medium=referral)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本週我們來讀一下「如何為開源做貢獻」。這份文件是 Github 的 Open Source Guide 開源指南，約莫兩年前剛出的時候全部是英文版的，已經三年了，拖到現在才讀（汗）。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;（這篇是閱讀開源指南的筆記，原創內容偏少，原文在下方連結）
&lt;a href=&quot;https://opensource.guide/zh-hant/how-to-contribute/&quot;&gt;&lt;strong&gt;如何為開源做貢獻？&lt;/strong&gt;
&lt;em&gt;透過為開源貢獻力量，能從中學習、幫助他人並且從中累積相關技能的經驗 - 任何你能想像得到的技能。 為什麼會有人為開源做出貢獻？有數不清的原因！…&lt;/em&gt;opensource.guide&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;是 Github 7000 顆星星的開源專案
&lt;a href=&quot;https://github.com/github/opensource.guide&quot;&gt;&lt;strong&gt;github/opensource.guide&lt;/strong&gt;
&lt;em&gt;Open Source Guides ( https://opensource.guide/) are a collection of resources for individuals, communities, and…&lt;/em&gt;github.com&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;為何要貢獻開源專案&quot;&gt;&lt;strong&gt;為何要貢獻開源專案？&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;原文寫的很好，我用我的話說出來。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;1-打磨你的專業技能&quot;&gt;1. 打磨你的專業技能&lt;/h3&gt;

&lt;p&gt;專案中包含了撰寫程式碼、平面設計、使用者體驗設計、撰寫文章 … 等等的工作。只要你想，你就可以在開源專案中找到你的位置。&lt;/p&gt;

&lt;h3 id=&quot;2-認識與你有相似興趣的人&quot;&gt;2. 認識與你有相似興趣的人&lt;/h3&gt;

&lt;p&gt;我覺得這真的滿重要，在現實生活中要找到相同興趣的人就很困難了，但是透過貢獻開源，你可以無遠弗屆的認識世界各地與你有相似興趣的人。&lt;/p&gt;

&lt;h3 id=&quot;3-鍛鍊溝通能力&quot;&gt;3. 鍛鍊溝通能力&lt;/h3&gt;

&lt;p&gt;因為開源專案是一個「共同協做」的專案。你需要向他人解釋自己是用什麼方法實作，也會需要其他人的幫助。&lt;/p&gt;

&lt;h3 id=&quot;4-建立名聲&quot;&gt;4. 建立名聲&lt;/h3&gt;

&lt;p&gt;你在開源專案中實作的成果一切都是看的到的，這也意味開源專案是一個能好好火力展示的地方。&lt;/p&gt;

&lt;h3 id=&quot;5-學習人際關係的能力&quot;&gt;5. 學習人際關係的能力&lt;/h3&gt;

&lt;p&gt;開源為練習領導及管理的能力提供了很好的機會。例如如何解決衝突、組織團隊以及如何為工作的優先順序排列。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;小訣竅：走進開源專案，就像你走進一群陌生人中，想要嘗試融入。這群人討論的非常深入了，你突然打岔肯定會讓人覺得奇怪。
 與其盲目地在社群中拋出你自己的看法，不如先觀察一下社群的氛圍後再提出，這樣你的想法被注意到的機會才會增加。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;找尋專案開始貢獻&quot;&gt;找尋專案開始貢獻&lt;/h2&gt;

&lt;p&gt;如果你還未貢獻任何一個開源專案的話，可以想想，你能夠為開源專案做些什麼？&lt;/p&gt;

&lt;p&gt;可以從你有使用過的開源專案開始著手，跟你比較有關係的開源專案，或是你比較感興趣的開源專案，你才會積極的參加。&lt;/p&gt;

&lt;p&gt;平均一個專案有 28% 的貢獻是隨意且偶然的，像是 Readme、改錯字、失效連結 … 等等的小地方。&lt;/p&gt;

&lt;h2 id=&quot;找到專案時先確保專案是否接受貢獻&quot;&gt;&lt;strong&gt;找到專案時，先確保專案是否接受貢獻&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;可以從幾個地方，看出專案是否活躍，樂於接受貢獻：&lt;/p&gt;

&lt;p&gt;從 Master 分支上看看觀察&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;最近一次的 Commit 是什麼時候？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Commit 的次數頻繁嘛？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;專案目前有多少貢獻者？&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;從 Issue 觀察&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;目前有多少個 issue&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;維護者回覆 issue 是否迅速&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;是否有討論熱絡的 issue&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;issue 是否已經大量累積&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最近 close 的 issue 是多久以前&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;從 PR 觀察&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;有多少處於進行中的 PR&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;提交 PR 後維護者回覆是否迅速&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最近有多少 PR 被 Merge&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;觀察專案的友善程度&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;維護者的回應是否有幫助&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;討論過程是否親切&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;會不會審查 PR&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;如何將成果貢獻至開源專案&quot;&gt;如何將成果貢獻至開源專案&lt;/h2&gt;

&lt;p&gt;最重要的是「有效的溝通」，把握幾個要點：&lt;/p&gt;

&lt;h3 id=&quot;1-交代來龍去脈&quot;&gt;1. 交代來龍去脈&lt;/h3&gt;

&lt;p&gt;讓他人快速的理解。如果是 Bug 交代清楚你想做的事情是什麼，你當實作了哪些步驟，以便重現錯誤。如果你想要發起一個新的想法，你要解釋為什麼你要這樣做，為什麼你覺得這樣會對專案有幫助。&lt;/p&gt;

&lt;h3 id=&quot;2-做好準備工作&quot;&gt;2. 做好準備工作&lt;/h3&gt;

&lt;p&gt;在尋求幫助之前，先確保你看過文件、相關 Issue 的討論，當你表達出強烈的意願時，人們會很樂意幫助你的。&lt;/p&gt;

&lt;h3 id=&quot;3-溝通時力求精簡明瞭&quot;&gt;3. 溝通時力求精簡明瞭&lt;/h3&gt;

&lt;p&gt;開源專案每次提交都是需要他人檢閱的，如果你能夠精準的表達你的看法，那麼你得到別人幫助的機會就會大幅提昇。&lt;/p&gt;

&lt;h3 id=&quot;4-大膽的提問但是要有耐心&quot;&gt;&lt;strong&gt;4. 大膽的提問（但是要有耐心！）&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;每個人都有新手的時候，不要怕提問。需要注意的是長期維護的人不一定熟悉專案的每一個部分。協作時表現出你的耐心，你會得到相同回報。&lt;/p&gt;

&lt;h3 id=&quot;5-尊重社群的決定&quot;&gt;5. 尊重社群的決定&lt;/h3&gt;

&lt;p&gt;有時候你的看法跟社群的看法不一定相同。他們可能不接受你的建議。可能社群最後不接納你的建議。這時你可以試試看討論出折衷方案，或者將專案 fork 另起爐灶。&lt;/p&gt;

&lt;h2 id=&quot;提交之後&quot;&gt;提交之後&lt;/h2&gt;

&lt;h3 id=&quot;有可能沒有人理你&quot;&gt;😭有可能沒有人理你&lt;/h3&gt;

&lt;p&gt;因為大家都很忙，尤其是熱門的開源專案。Issue 很多，維護者的人手不夠，此時就先耐心的等待。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;千萬不要私下聯絡，在開源專案中，一切的溝通都應該是公開的。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;有人希望你修改你的貢獻&quot;&gt;🚧有人希望你修改你的貢獻&lt;/h3&gt;

&lt;p&gt;這是好的開始，溝通、改進直到符合維護者得期待。&lt;/p&gt;

&lt;h3 id=&quot;你的貢獻沒有被採納&quot;&gt;👎你的貢獻沒有被採納&lt;/h3&gt;

&lt;p&gt;你的工作最後沒有被採納，這時你可以問問維護者，為什麼沒有被採納。需要注意的是別花時間在爭論上，這會讓你樹立更多敵人。&lt;/p&gt;

&lt;h3 id=&quot;-你的貢獻被接受&quot;&gt;🎉 你的貢獻被接受。&lt;/h3&gt;

&lt;p&gt;太棒了！你完成了一次開源貢獻！&lt;/p&gt;

&lt;h2 id=&quot;延伸閱讀&quot;&gt;延伸閱讀&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://opensource.guide/zh-hant/starting-a-project/&quot;&gt;&lt;strong&gt;發起一個開源專案&lt;/strong&gt;
&lt;em&gt;所以你在考慮開始參與開源？恭喜！世界讚賞你的貢獻。讓我們來談談開源是什麼，以及人們這樣做。 當一個專案被開源，這意味着 任何人都可以出於任何目的查看，使用，修改和分發你的專案。 這些權限通過 開源許可 強制實施。…&lt;/em&gt;opensource.gu&lt;/a&gt;
&lt;a href=&quot;https://opensource.guide/zh-hant/best-practices/&quot;&gt;&lt;strong&gt;維護者最佳實踐&lt;/strong&gt;
&lt;em&gt;如果你維護著一個非常流行的專案，你可能就會意識到自己寫程式的時間變少，而花費在回答issue的時間越來越多。…&lt;/em&gt;opensource.guide&lt;/a&gt;
&lt;a href=&quot;https://opensource.guide/zh-hant/leadership-and-governance/&quot;&gt;&lt;strong&gt;領導與治理&lt;/strong&gt;
&lt;em&gt;當專案開始有條不紊的進行，人員也開始穩定，那麼你就應該開始社群的治理了。對於社群的治理，你或許有一些疑問，諸如如何將常規專案的貢獻者納入你的工作流？如何才能判斷應該賦予誰提交的權限？又或者是如何解決社群的債務？如果你對這些有疑問的話，我們這…&lt;/em&gt;opensource.guide&lt;/a&gt;
&lt;a href=&quot;https://opensource.guide/zh-hant/code-of-conduct/&quot;&gt;&lt;strong&gt;建立一套行為準則&lt;/strong&gt;
&lt;em&gt;行爲守則是一份確立專案參與者行爲規範的文件。採用和執行行爲守則可以幫助你們的社群營造積極的氛圍。…&lt;/em&gt;opensource.guide&lt;/a&gt;
&lt;a href=&quot;https://opensource.guide/zh-hant/finding-users/&quot;&gt;&lt;strong&gt;找尋專案的使用者&lt;/strong&gt;
&lt;em&gt;沒有規定說應該怎麼去倡導剛創建的開源專案。但沒有任何理由說必須默默無聞的在開源專案上工作。相反，如果你向有更多的人發現和使用你的開源專案，你就應該讓所有人知道你所努力的成果！…&lt;/em&gt;opensource.guide&lt;/a&gt;&lt;/p&gt;</content><author><name>Luka</name></author><category term="Github" /><category term="Open Source" /><summary type="html">從 Github 開源指南｜學習如何貢獻開源專案</summary></entry><entry><title type="html">TLDR 命令列神兵｜Linux 入門必裝</title><link href="https://lukahuang.com/tldr/" rel="alternate" type="text/html" title="TLDR 命令列神兵｜Linux 入門必裝" /><published>2020-07-28T16:01:00+00:00</published><updated>2020-07-28T16:01:00+00:00</updated><id>https://lukahuang.com/tldr</id><content type="html" xml:base="https://lukahuang.com/tldr/">&lt;h2 id=&quot;tldr-命令列神兵linux-入門必裝&quot;&gt;TLDR 命令列神兵｜Linux 入門必裝&lt;/h2&gt;

&lt;h3 id=&quot;tldr-的意思是哩供蝦講重點好嘛&quot;&gt;TL;DR 的意思是：哩供蝦？講重點好嘛？&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/4000/0*UzoUjUPMJFmux31Z&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;TLDR 能夠讓初學程式的新手 ，輕鬆了解命令列工具的各種 Linux 指令，並且自由運用。本篇文章分成幾個兩個部分：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;命令列工具 Command line tool 到底是什麼東西？&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TLDR 是什麼東西？它如何幫助我們快速適應 Linux 命令列工具？&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;話不多說，我們開始吧。&lt;/p&gt;

&lt;h2 id=&quot;命令列工具-command-line-tool-到底是什麼&quot;&gt;命令列工具 Command line tool 到底是什麼？&lt;/h2&gt;

&lt;p&gt;命令列工具的英文是 Command Line Tool。下圖就是常見的命令列工具。那麼他的作用是什麼呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2728/0*SpNBj5mNjdNKxJoh.png&quot; alt=&quot;source: [http://www.blogjava.net/xiaomage234/archive/2016/04/06/429988.html](http://www.blogjava.net/xiaomage234/archive/2016/04/06/429988.html)&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;命令列工具的作用是「透過下指令的方式來做到你想做的事情」&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;這是什麼意思？為什麼要透過下指令的方式讓做事？原因是：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;用命令列工具的來做事情非常有效率。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;試想如果你想要安裝一個知名影音播放軟體 VLC，你會做些什麼事情？首先你會 Google，開幾個網頁，看看哪個載點比較值得信賴，然後選一個覺得不錯的下載，等到下載完成之後再安裝。&lt;/p&gt;

&lt;p&gt;哪麼換成命令列工具呢，只要下一行指令即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew cask install vlc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;來看看會發生什麼事情？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*BCtzem0SRoWkPqgmnD2CTA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;VLC 已經裝好了，終端機顯示 VLC 安裝在 /Applications/VLC.app。接著我們打開 /Application 資料夾，VLC 已經安裝好了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*ZL62K8u1qBANq5qvGu5hVg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;也許你覺得用手動點擊也可以幫你做到同樣的事情，但是當這種有效率的小動作逐步累積的時候，就會造成效率上的極大差異。別人用 15 分鐘做好的事情你可能需要花一個小時。隨著做的事情越複雜效率的差異會越大。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;h1 id=&quot;命令列工具那麼好用-那到底要怎麼用&quot;&gt;命令列工具那麼好用？ 那到底要怎麼用？&lt;/h1&gt;
  &lt;h1 id=&quot;tldr-就是告訴我們各種-linux-指令怎麼用的工具&quot;&gt;tldr 就是告訴我們各種 Linux 指令怎麼用的工具。&lt;/h1&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;tldr-登場看看它如何大發神威&quot;&gt;TLDR 登場，看看它如何大發神威&lt;/h2&gt;

&lt;p&gt;這下子就輪到我們的主角登場啦，TLDR！TLDR 能夠用最簡短的方式告訴你各種指令的用法。&lt;/p&gt;

&lt;p&gt;TL;DR 是 too long; didn’t read 的縮寫，初學 Linux 的時候一堆指令的縮寫有夠難懂，什麼 ls、pwd、mv … 諸如此類的指令。當你不懂的時候怎麼辦？用 TLDR 就對了！&lt;/p&gt;

&lt;p&gt;來示範一下怎麼用，假設我們不知道 ls 指令怎麼使用。想破頭也不知道 ls 指令到底用來幹嘛的？ 輸入 tldr ls 立刻了解 ls 如何使用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*tvVThnRqBgBo-yhGebG62g.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;從上圖中的第一行就告訴你，ls 的功用是列出目前資料夾的內容。如果你需要更多的用法，可以參照 tldr 幫你精選出來的各種常用指令。&lt;strong&gt;TLDR 絕對不完整，但是很容易上手！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另一種對比的 Linux 完整文件的指令是 man，在終端機輸入 man ls ，呈現的樣子如下圖，落落長，跟 TLDR 完全相反，保證完整，但要看很久。我們常常只是要用 Linux 指令做一些簡單的事情，所以並不需要看的那麼仔細。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*nGYQ67CJakspwFZkrsaX3w.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再來試試看 pwd，可以很清楚的看到 pwd的功用是印出目前工作的目錄。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*F3QTTv-8uiohS8hvHr7cMg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然後你再輸入一次 pwd，就可以很清楚的知道「顯示出來的內容是目前的工作目錄」&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*uwhc7FNdVPZTmBPQXWVe0A.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;tldr-如何安裝&quot;&gt;TLDR 如何安裝？&lt;/h2&gt;

&lt;p&gt;既然是新手教學文，最後我們就來講一下怎麼安裝&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install -g tldr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一行指令搞定，就是這麼輕鬆寫意。&lt;/p&gt;

&lt;h2 id=&quot;小結&quot;&gt;小結&lt;/h2&gt;

&lt;p&gt;TLDR 的出現，讓我除了&lt;a href=&quot;http://linux.vbird.org/&quot;&gt;鳥哥的Linux 私房菜&lt;/a&gt;以外多了一個認識 Linux 指令的管道。更有趣的它是一個開源專案，如果用 tldr 某某指令 找不到結果，你還可以自行貢獻自己的小抄，讓世界上的其他人用得到。對於新手來講是一個滿好入門的工具。&lt;/p&gt;

&lt;p&gt;如果覺得我的文章對你有幫助 ，&lt;a href=&quot;https://medium.com/@LukaTW&quot;&gt;來 follow 我吧&lt;/a&gt;！最近我會常寫文的呦。
也別忘了 follow 星巴哥技術週刊，每週推送優質原創文章！&lt;/p&gt;</content><author><name>Luka</name></author><summary type="html">TLDR 命令列神兵｜Linux 入門必裝</summary></entry><entry><title type="html">Kubernetes IDE - Lens 用圖形化介面管理 K8S</title><link href="https://lukahuang.com/lens-the-ide-for-kubernetes/" rel="alternate" type="text/html" title="Kubernetes IDE - Lens 用圖形化介面管理 K8S" /><published>2020-06-30T17:01:00+00:00</published><updated>2020-06-30T17:01:00+00:00</updated><id>https://lukahuang.com/lens-the-ide-for-kubernetes</id><content type="html" xml:base="https://lukahuang.com/lens-the-ide-for-kubernetes/">&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2400/0*P3QeV7d9iPBNeOCr.png&quot; alt=&quot;https://k8slens.dev&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以往我們在管理 Kubernetes 集群的時候，需要大量的命令列操作，需要去四處找尋需要的資訊，例如你想看 Node 的狀態你可能需要在 AWS Console 上面看，如果你用的是 GKE 的話你就需要到的 GCP 的後台上看。你想要進入 Pod 你需要先下 kubectl get pods取得 pod 列表，接著再下 kubectl exec -it pod/xxxpod – bash 進入。&lt;/p&gt;

&lt;p&gt;這些功能現在 Lens 全部幫你整合進去了。它能夠讓你快速的瀏覽你的 K8S 集群狀況，並且即時反應 K8S 集群的狀態讓你可以做相對應的反應。我們就來看看 Lens 有哪些殺手級的功能吧！&lt;/p&gt;

&lt;h2 id=&quot;lens-有哪些殺手級功能&quot;&gt;Lens 有哪些殺手級功能&lt;/h2&gt;

&lt;h2 id=&quot;1-實時監控-pod-的狀態-realtime-monitoring&quot;&gt;1. 實時監控 pod 的狀態 (realtime monitoring)&lt;/h2&gt;

&lt;p&gt;可以實時監控 pod 的狀態，不需要手動刷新，這個功能我覺得滿方便的。一般來說你想要重複獲取 pod 的狀態需要在終端機中輸入 kubectl get pods，用終端機下指令的方式只能知道下指令的「當下的狀態」，如果你想要獲得你想要的狀態，你必須不斷下指令。而現在使用 Lens 你只需要瞄一下螢幕，就可以知道 pod 就緒了沒，因為 Lens 會告訴你最即時的 Pod 狀態。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*ce7US7IAR0EPDvYlQIrhBQ.png&quot; alt=&quot;為了不透漏機密資訊我使用 Lens 官方網站的圖片 ([https://k8slens.dev/](https://k8slens.dev/))&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-快速查看-pod-的-cpu-記憶體用量&quot;&gt;2. 快速查看 Pod 的 CPU 、記憶體用量&lt;/h2&gt;

&lt;p&gt;我覺得這是令人滿驚艷的功能，Newrelic 針對 K8S 推出的監控工具操作起來都沒有那麼直覺。因此目前的監控方案用 Newrelic 來看吞吐量與 request 的消耗時間，方便做一些效能調校。而觀看 Kubernetes 整體的狀態則是使用 Lens 為主。能夠快速找到想要的資訊並能夠反應實時(realtime)的狀態真的挺重要。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*Jv4voRbrXD7vFogoFwBskg.png&quot; alt=&quot;image from [https://k8slens.dev/](https://k8slens.dev/)&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-快速觀看-node-的狀態&quot;&gt;3. 快速觀看 Node 的狀態&lt;/h2&gt;

&lt;p&gt;Pod 是 Kubernetes 中的最小單位，但最後他還是會跑在某一台實體機器，也就是 Node 上面，所以我們可以快速的看到 Node 的狀態也是很重要的。&lt;/p&gt;

&lt;p&gt;沒錯，Lens 就是那麼的威，可以快速的看到 K8S 中 Node 的 CPU、記憶體用量，還有 Node 上跑了哪些 Pod，運行了哪些資源。&lt;/p&gt;

&lt;p&gt;我覺得根本整合度極高。偏愛用終端機的我，目前也離不開 Lens 的方便。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/3340/1*XGv9gmMz73ZKZjw_bEb_ww.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-event-列表能夠即時知道-k8s-集群發生了什麼事&quot;&gt;4. Event 列表，能夠即時知道 K8S 集群發生了什麼事&lt;/h2&gt;

&lt;p&gt;例如：一個 pod 中的 readiness probe 告訴你：你的 pod 還沒有準備好啦！Lens 就有這個功能，可以即時知道 K8S Cluster 的事件。不然很有可能 Kubernetes 發生了一些事情，但是你沒有察覺。&lt;/p&gt;

&lt;h2 id=&quot;5-pod---terminal-一鍵搞定&quot;&gt;5. Pod -&amp;gt; Terminal 一鍵搞定&lt;/h2&gt;

&lt;p&gt;平常要進入某 Pod 的時候先 k get pods，然後複製貼上 pod 的名稱，輸入 k exec -it pod/your-pod-name – /bin/bash 每次做真的有點煩。Lens 直接列出所有 Pod，你只需要點選有問題的 Pod，或是你想要進去的 Pod，點擊終端機鍵，即可連進 Pod 裡面。真～是～太～方～便～啦～！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2790/1*yGkNYU4kdqJ85C7u-Aq0Og.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;為什麼-kubernetes-能夠有一款-ide&quot;&gt;為什麼 Kubernetes 能夠有一款 IDE？&lt;/h2&gt;

&lt;p&gt;最後來聊一聊為什麼 Kubernetes 能夠出一款 IDE？一般來說 IDE 是基於語言設計出的 IDE，例如：java 有 Eclipse，c# 有 visual studio，Python 有 Pycharm，PHP 有 Phpstorm… 等等。&lt;/p&gt;

&lt;p&gt;這些以語言為基礎的 IDE 可以提供語言為基礎的一些好用方法。例如方法的自動完成、原始碼的快速查找，或是提取方法、提取參數 … 等等重構的功能。基於每個語言的特性，IDE 提供不同的特性。&lt;/p&gt;

&lt;p&gt;Kubernetes 的 IDE 是怎麼回事呢？各家提供雲服務的平台紛紛推出相對應 K8S 的服務。例如：Google 有 GKE，AWS 有 EKS，或是也可以自行架設 Kubernetes 集群。&lt;/p&gt;

&lt;p&gt;這些 Kubernetes 服務都遵循著相同的 Kubernetes 規範，聽起來好像有點繞，如果不是因為有 Kubernetes 這樣明確的規範，就不可能有 IDE 產生。&lt;/p&gt;

&lt;p&gt;例如：Google 的雲端平台 GCP 上如果你想要開機器，跟 AWS 平台上你想要開機器，那麼你是無法用一套 IDE 來監控或是控制兩者的機器狀態的。因為 Google 和 AWS 機器呼叫的規格各自有各自的定義，無法共通。&lt;/p&gt;

&lt;p&gt;而 Kubernetes 大家都是透過 kubectl 來跟 Kubenetes Control Panel 溝通。Kubenetes 中的元件，例如：Pod、Service、Deployment … 等等，在各家雲服務商也都是遵照相同規範實作，因此可以使用一款 IDE，就能夠監控各家的 Kubernetes 集群。&lt;/p&gt;

&lt;h2 id=&quot;結語&quot;&gt;&lt;strong&gt;結語&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;Lens 的出現讓我用最少的力氣就可以快速的看到想看的資訊。而 Newrelic 的方式比較像是以往的 APM 的監控法。跟以前只有機器的時代，多了一層 Kubernetes 多了滿多思考點。另外警報(Alert)又是另一套系統了。如何在問題出現的時候，快速定位問題，在使用者察覺前解決掉，是一個有趣的挑戰。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;最後不免俗的感謝大家觀看，喜歡我的文章請訂閱 Starbugs 星巴哥技術專欄，每週推送原創好文😀😀😀&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Luka</name></author><category term="Kubernetes" /><summary type="html"></summary></entry><entry><title type="html">TPM — 套件管理工具 ，讓你的 TMUX 更好用</title><link href="https://lukahuang.com/tmp-let-your-tmux-better/" rel="alternate" type="text/html" title="TPM — 套件管理工具 ，讓你的 TMUX 更好用" /><published>2020-06-02T19:51:00+00:00</published><updated>2020-06-02T19:51:00+00:00</updated><id>https://lukahuang.com/tmp-let-your-tmux-better</id><content type="html" xml:base="https://lukahuang.com/tmp-let-your-tmux-better/">&lt;h2 id=&quot;tpm--套件管理工具-讓你的-tmux-更好用&quot;&gt;tpm — 套件管理工具 ，讓你的 tmux 更好用&lt;/h2&gt;

&lt;p&gt;最近因為工作上需要用到開很多個視窗的情景，研究了一下如何把 tmux 變得更具有生產力。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/0*wJrJdR3tFO84Tdsd.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;tmux-是什麼&quot;&gt;tmux 是什麼？&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/tmux/tmux&quot;&gt;tmux&lt;/a&gt; 是一個很好用的遠端 session 管理套件，兼具效能與功能性，可以讓你在遠端伺服器中，輕易管理背景執行程式。&lt;/p&gt;

&lt;p&gt;Larry 在 **&lt;a href=&quot;https://larrylu.blog/tmux-33a24e595fbc&quot;&gt;終端機 session 管理神器 — tmux&lt;/a&gt; **文章中介紹了基本的概念、使用方式與經典的使用情景。如果沒有看過的話，請看文章了解一下。
&lt;a href=&quot;https://larrylu.blog/tmux-33a24e595fbc&quot;&gt;&lt;strong&gt;終端機 session 管理神器 — tmux&lt;/strong&gt;
&lt;em&gt;身為一名開發者對終端機應該不陌生，不管是要執行腳本、ssh 到遠端伺服器都會用到終端機。
這邊要介紹給大家一個工具 tmux，tmux 是個 terminal multiplexer，可以讓你的終端機更好用&lt;/em&gt;larrylu.blog&lt;/a&gt;&lt;a href=&quot;https://larrylu.blog/tmux-33a24e595fbc&quot;&gt;t&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不過其實不看也沒什麼關係啦，看我寫得就好&lt;em&gt;。&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;hello-tpm&quot;&gt;Hello, tpm&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/tmux-plugins/tpm&quot;&gt;tpm&lt;/a&gt; 是 tmux 的套件管理工具，英文是 Tmux Plugin Manager。tmux 之於 tpm 就如同是 nodejs 之於 npm。是一個在 github 上面有 6100 顆星星的開源專案。&lt;/p&gt;

&lt;p&gt;今天我的重點放在 tpm 的介紹上，如果還沒安裝 tmux，請按照 **&lt;a href=&quot;https://larrylu.blog/tmux-33a24e595fbc&quot;&gt;終端機 session 管理神器 — tmux&lt;/a&gt; **文章中的教學逐步安裝並學習使用方法。&lt;/p&gt;

&lt;p&gt;回過頭來，我們想要用 tpm 來安裝一些好用的套件，先安裝好 tpm。 首先 git clone tpm 至本機。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone [https://github.com/tmux-plugins/tpm](https://github.com/tmux-plugins/tpm) ~/.tmux/plugins/tpm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接著修改 ~/.tmux.conf 檔案的內容，將下列內容複製貼上至檔案中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# List of plugins
set -g @plugin 'tmux-plugins/tpm'
set -g @plugin 'tmux-plugins/tmux-sensible'

# Other examples:
# set -g @plugin 'github_username/plugin_name'
# set -g @plugin 'git@github.com/user/plugin'
# set -g @plugin 'git@bitbucket.com/user/plugin'

# Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)
run -b '~/.tmux/plugins/tpm/tpm'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安裝完成後在終端機中輸入下列指令或是重開終端機即可載入完成。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tmux source ~/.tmux.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;要怎麼使用-tpm-安裝-tmux-套件&quot;&gt;要怎麼使用 tpm 安裝 tmux 套件&lt;/h2&gt;

&lt;p&gt;安裝 tpm 套件可能跟你想的不太一樣，直接修改 ~/.tmux.conf 檔案的內容，並且重啟。例如你想要安裝 &lt;a href=&quot;https://github.com/tmux-plugins/tmux-copycat&quot;&gt;tmux-copycat&lt;/a&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vim ~/.tmux.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;加入這一行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set -g @plugin 'tmux-plugins/tmux-copycat'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接著，重開 tmux session 或是在 tmux 中輸入 prefix (ctrl+b) + I 即可。&lt;/p&gt;

&lt;h2 id=&quot;ctrlb-有點遠修改-prefix-為-ctrl--a&quot;&gt;ctrl+b 有點遠，修改 prefix 為 ctrl + a&lt;/h2&gt;

&lt;p&gt;tmux 大部分的指令是由組合鍵 prefix + 某某鍵所構成。 prefix 預設是 ctrl + b，外國鄉民大多是將 prefix 修改成 ctrl + a ，你也可以設成你喜歡的樣子，設定方法很簡單。在 .tmux.conf 中加上以下內容即可將 prefix 變成ctrl + a。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# remap prefix from 'C-b' to 'C-a'
unbind C-b
set-option -g prefix C-a
bind-key C-a send-prefix
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;介紹幾個好用的套件&quot;&gt;介紹幾個好用的套件&lt;/h2&gt;

&lt;h3 id=&quot;tmux-yank&quot;&gt;&lt;a href=&quot;https://github.com/tmux-plugins/tmux-yank&quot;&gt;tmux-yank&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;讓你的 tmux 可以用系統的剪貼簿，支援 osx, linux, WSL(Windows Subsystem for Linux) … 等等的環境。&lt;/p&gt;

&lt;h3 id=&quot;tmux-pain-control&quot;&gt;&lt;a href=&quot;https://github.com/tmux-plugins/tmux-pain-control&quot;&gt;tmux-pain-control&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;這個套件有三大功能，第一是切割視窗，第二是在視窗中跳躍，第三是縮放視窗大小。&lt;/p&gt;

&lt;h3 id=&quot;讓切割視窗變得更加簡單&quot;&gt;讓切割視窗變得更加簡單&lt;/h3&gt;

&lt;p&gt;這兩個是 tmux 預設的切割視窗快捷鍵&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;prefix + “：進行&lt;strong&gt;水平&lt;/strong&gt;分割&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;prefix + %：進行&lt;strong&gt;垂直&lt;/strong&gt;分割&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;這兩個符號我一直記不起來😭，但是在使用&lt;a href=&quot;https://github.com/tmux-plugins/tmux-pain-control&quot;&gt;tmux-pain-control&lt;/a&gt; 之後：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;prefix +&lt;/td&gt;
          &lt;td&gt;：進行&lt;strong&gt;水平&lt;/strong&gt;分割&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;prefix + -：進行&lt;strong&gt;垂直&lt;/strong&gt;分割&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;圖型記憶法，真是太好記了。連續技用起來會有這樣的效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*P3MQZDaihxlpHZwBNTvdpQ.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;用-vim-的方向鍵跳轉視窗&quot;&gt;用 vim 的方向鍵跳轉視窗&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;prefix + h：往左跳&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;prefix + j：往上跳&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;prefix + k：往下跳&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;prefix + l：往右跳&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*F-mk4CsL1oh36EDK_cRr0g.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;用-vim-的方向鍵縮放視窗&quot;&gt;用 vim 的方向鍵縮放視窗&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;prefix + shift + h：視窗邊界往左移&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;prefix + shift + j：視窗邊界往上移&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;prefix + shift + k：視窗邊界往下移&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;prefix + shift + l：視窗邊界往右移&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*lv0mJUFUVHmxCZMPuctZRg.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tmux-copycat&quot;&gt;&lt;a href=&quot;https://github.com/tmux-plugins/tmux-copycat&quot;&gt;tmux copycat&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;tmux copycat 可以讓你不使用滑鼠就能夠複製文字。這個套件非常好用，礙於時間不夠無法錄製完整操作。殘念。&lt;/p&gt;

&lt;h3 id=&quot;tmux-resurrect&quot;&gt;&lt;a href=&quot;https://github.com/tmux-plugins/tmux-resurrect&quot;&gt;tmux-resurrect&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;讓系統重啟的時候保持 tmux 的設定。&lt;/p&gt;

&lt;h3 id=&quot;tmux-open&quot;&gt;&lt;a href=&quot;https://github.com/tmux-plugins/tmux-open&quot;&gt;tmux-open&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;能夠讓你快速的打開你選取到的文字對應的超連結或是檔案。&lt;/p&gt;

&lt;h3 id=&quot;tmux-prefix-highlight&quot;&gt;&lt;a href=&quot;https://github.com/tmux-plugins/tmux-prefix-highlight&quot;&gt;tmux-prefix-highlight&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;讓你知道你有沒有成功觸發 prefix，如果按成功了，在下方顯示列會有成功觸發的圖案。&lt;/p&gt;

&lt;h3 id=&quot;tmux-continuum&quot;&gt;&lt;a href=&quot;https://github.com/tmux-plugins/tmux-continuum&quot;&gt;tmux-continuum&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;持續幫你儲存 tmux 的設定。&lt;/p&gt;

&lt;h3 id=&quot;tmux-sensible&quot;&gt;&lt;a href=&quot;https://github.com/tmux-plugins/tmux-sensible&quot;&gt;tmux-sensible&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;讓 tmux 比較合乎邏輯，不然 tmux 有些預設的設定實在是有點難用，這是必備的 tmux 套件。&lt;/p&gt;

&lt;h2 id=&quot;小結&quot;&gt;小結&lt;/h2&gt;

&lt;p&gt;有了 tpm 可以輕鬆安裝好用套件，這讓 tmux 平易進人多了，操作上不再需要記憶太多奇怪的快捷鍵。就可以讓生產力獲得大幅的提升，真滴好。&lt;/p&gt;

&lt;h2 id=&quot;參考資源&quot;&gt;參考資源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.hamvocke.com/blog/a-guide-to-customizing-your-tmux-conf/&quot;&gt;Making tmux Pretty and Usable — A Guide to Customizing your tmux.conf&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://medium.com/actualize-network/a-minimalist-guide-to-tmux-13675fb160fa&quot;&gt;A minimalist guide to tmux&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Luka</name></author><summary type="html">tpm — 套件管理工具 ，讓你的 tmux 更好用</summary></entry><entry><title type="html">Unit Test 中的替身：搞不清楚的Dummy 、Stub、Spy、Mock、Fake</title><link href="https://lukahuang.com/unit-test/" rel="alternate" type="text/html" title="Unit Test 中的替身：搞不清楚的Dummy 、Stub、Spy、Mock、Fake" /><published>2020-05-05T19:50:00+00:00</published><updated>2020-05-05T19:50:00+00:00</updated><id>https://lukahuang.com/unit-test</id><content type="html" xml:base="https://lukahuang.com/unit-test/">&lt;h2 id=&quot;unit-test-中的替身搞不清楚的dummy-stubspymockfake&quot;&gt;Unit Test 中的替身：搞不清楚的Dummy 、Stub、Spy、Mock、Fake&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/0*Xn1CY4WKjOu3AdhL.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最近開始接觸單元測試，一堆名詞看不懂，來狠狠地 K 一下。而單元測試中的最佳男配角，就是替身 Double。藉由寫一篇文章的方式來讓自己更了解單元測試中的重要部分。一起來學寫測試，Go Go !!&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;註：接觸時間還很短，有錯還請不吝指正，如果之後發現我有理解錯誤再回來更正。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;單元測試是什麼&quot;&gt;單元測試是什麼？&lt;/h2&gt;

&lt;p&gt;單元測試可以讓你快速驗證程式的行為。了解單元測的話首先來介紹一下 SUT 目標對象。&lt;/p&gt;

&lt;p&gt;舉個例子：你想要測試一台車是不是可以開，那麼 SUT 目標對象就是這台車。&lt;/p&gt;

&lt;p&gt;為了確保這台車可以開，那麼就可以寫一個「這台車應該要可以開」的測試。如果這台車發生了故障，測試就會告訴你，這台車是壞掉的。&lt;/p&gt;

&lt;p&gt;單元測試讓你的程式更容易維護。原因在於你能夠對程式寫測試，代表你寫的程式的「使用說明書」清楚易懂。使用說明書很容易懂，就可以直接拿來用，減少重複的程式碼，符合 DRY (Don’t Repeat Yourself) 原則。&lt;/p&gt;

&lt;p&gt;寫程式最大的成本在於維護，寫很簡單，但是要維護可就是個不容易的事情了。為了降低維護的成本，導入單元測試可以大大降低出錯的可能性，並且快樂地重構。&lt;/p&gt;

&lt;h2 id=&quot;替身是什麼&quot;&gt;替身是什麼？&lt;/h2&gt;

&lt;p&gt;下圖是火影忍者的替身之術，替身之術的原理是：當敵人對你發動攻擊時，你使用替身之術，就可以讓替身承受敵人的攻擊，而自己不會受到傷害。圖中的木頭就是呼叫替身之術後，用來承受敵人攻擊的替身。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/0*j4xWCtfCJnjEpjvR.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以火影忍者替身之術跟 Unit Test 的替身有什麼關係？你在程式中使出替身之術的時候，替身 Double 就會出現在你的程式裡面了。&lt;/p&gt;

&lt;h2 id=&quot;為什麼要在程式中使用替身-double-呢&quot;&gt;為什麼要在程式中使用替身 Double 呢？&lt;/h2&gt;

&lt;p&gt;原因在於你想要測試的 SUT 目標對象通常會有很多「依賴」DOC。一樣舉個例子：剛剛的 SUT 目標對象是「一台車」很容易寫測試，只要測試這台車可以開就好。&lt;/p&gt;

&lt;p&gt;但是如果一台車停在停車場，然後又爆胎。或是一台車掉到海裡。這些情況，一台車的 DOC 依賴變多了，造成你的測試更加複雜，越多的 DOC 依賴會造成你的測試越難寫，也造成你的程式行為更加複雜，難以預測。&lt;/p&gt;

&lt;p&gt;那麼就進入正題來介紹測試中的幾種替身吧&lt;/p&gt;

&lt;h2 id=&quot;測試中的五種替身&quot;&gt;測試中的五種替身&lt;/h2&gt;

&lt;p&gt;測試中的 Double 替身分為五種：Dummy Object、Test Stub、Test Spy、Mock Object、Fake Object。先來介紹第一種 Dummy Object 冒牌貨&lt;/p&gt;

&lt;h2 id=&quot;dummy-object&quot;&gt;Dummy Object&lt;/h2&gt;

&lt;p&gt;Dummy Object 英文直譯冒牌貨，顧名思義就是個冒牌貨。他的用途是用來填充 SUT 目標測試對象中需要的物件。而 Dummy 不會對 SUT 測試目標造成任何的影響。純粹的填充物件，讓測試程式能夠運行。&lt;/p&gt;

&lt;h2 id=&quot;test-stub&quot;&gt;Test Stub&lt;/h2&gt;

&lt;p&gt;我們想要驗證的 SUT 回傳值，這時候 Stub 就可以派上用場啦。聽起來有點玄，一樣舉個例子：例如：現在我們的測試目標 SUT 是一個手電桶，我們想要驗證呼叫打開 on 方法的結果，而一個手電筒裡面需要裝電池，電池可能會沒電，但是我不想讓電池沒電這個因素影響我的測試。所以我做了一組替身電池 (Stub Object) 塞進這個手電筒裡面。讓我可以輕鬆驗證 SUT 的回傳值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Flashlight
  attr :battery  

  def initialize(battery)
    @battery = battery
  end  

  def on
    battery.have_energy? ? 'flashlight is turn on!' : 'no energy'
  end

end

Flashlight.new(StubBattery.new).on # 電池有沒有電不會影響結果。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;test-spy&quot;&gt;Test Spy&lt;/h2&gt;

&lt;p&gt;Spy 用來驗證 SUT 與對其他 DOC 物件造成的效果，例如：今天阿牛去找朋友聊天的時候，朋友物件內部的聊天次數就會加一，而當我們想想要驗證朋友物件的聊天次數是不是如我們所預期的增長時，我們就可以派出間諜朋友，來驗證「 SUT 阿牛是否有跟朋友聊三次天」之類的期待。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class 阿牛  

  def initialize(friend)
    @friend = friend
  end  

  def chat_to_friends
    friend.chat!
  end

end

class Friend 
  attr: chat_count  

  def chat
    @chat_count ||= 0
    @chat_count += 1
  end
end

cow = 阿牛.new(spy_friend)

cow.chat_to_friends
cow.chat_to_friends
cow.chat_to_friends

expect(spy_friend.chat_count).to eq(3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;mock-object&quot;&gt;Mock Object&lt;/h2&gt;

&lt;p&gt;Mock 是一個能夠判斷 SUT 是不是有正確使用 DOC 的替身。Mock 跟 Spy 的最大差別是，Mock 用來驗證 SUT 的行為，而 Spy 用來驗證 SUT 對 DOC 狀態的改變。&lt;/p&gt;

&lt;h2 id=&quot;fake-object&quot;&gt;Fake Object&lt;/h2&gt;

&lt;p&gt;Fake Object 假物件是一個簡化的 DOC (依賴元件)，例如：一台真實的飛機有很多零件，但是我們其實只需要他有外殼，並且可以飛，可以降落 … 等等的行為。所以做一個簡單版的假物件。假物件不需要考慮跟 SUT 目標對象的間接互動(Indirect input , indirect output)。&lt;/p&gt;

&lt;h2 id=&quot;其他不錯的資源&quot;&gt;其他不錯的資源&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://blog.pragmatists.com/test-doubles-fakes-mocks-and-stubs-1a7491dfa3da&quot;&gt;Test Doubles — Fakes, Mocks and Stubs.&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://julianchu.net/2018/08/16-test.html&quot;&gt;測試中常見的名詞：Stub, Dummy, Mock..等等&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.jyt0532.com/2018/01/04/test-double-spy/&quot;&gt;測試替身(5) — Spy&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Luka</name></author><category term="Unit Test" /><summary type="html">Unit Test 中的替身：搞不清楚的Dummy 、Stub、Spy、Mock、Fake</summary></entry><entry><title type="html">Kubernetes 教學 02 — 在 Minikube 上部屬 Python Flask 應用程式</title><link href="https://lukahuang.com/running-flask-on-minikube/" rel="alternate" type="text/html" title="Kubernetes 教學 02 — 在 Minikube 上部屬 Python Flask 應用程式" /><published>2020-03-10T19:50:00+00:00</published><updated>2020-03-10T19:50:00+00:00</updated><id>https://lukahuang.com/running-flask-on-minikube</id><content type="html" xml:base="https://lukahuang.com/running-flask-on-minikube/">&lt;blockquote&gt;
  &lt;p&gt;Minikube、kubectl 終於派上用場囉&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2088/0*BVfI3gXXICtmPkCu.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;前情提要&quot;&gt;前情提要&lt;/h2&gt;

&lt;p&gt;在 &lt;a href=&quot;https://medium.com/starbugs/954caa9b1558&quot;&gt;前一篇&lt;/a&gt; 中我們弄懂了 K8S Cluster、Node、Pod 與 Container 的關係，並且在文章末段介紹了能夠與 kubectl -「能夠與 K8S 溝通的命令列工具」。這次我們用實際的操作，來認識容器化的實際過程，並把它部屬到本地的 Kubernetes 上面。&lt;/p&gt;

&lt;h2 id=&quot;什麼是-minikube-&quot;&gt;什麼是 Minikube ？&lt;/h2&gt;

&lt;p&gt;Minikube 是一個單節點的 Kubernetes Cluster，可以安裝在本機上，支援 Windows 與 Mac Minikube 只有一個 Node (節點)。&lt;/p&gt;

&lt;p&gt;還記得 Node 是什麼嘛？來複習一下，Node 是一台實體機器，一個工作者 (worker)。上面可以搭載許多個 Pod，而 Pod 是 Kubernetes 的最小部屬單位。一個 Pod 由一個 Container 或是多個 Container 所組成。&lt;/p&gt;

&lt;p&gt;看完之後應該還是覺得有點繞，不過沒關係，因為今天我們就要透過實作來了解 Pod 到底是什麼。&lt;/p&gt;

&lt;h3 id=&quot;安裝-minikube&quot;&gt;安裝 Minikube&lt;/h3&gt;

&lt;p&gt;首先安裝 Minikube，請到&lt;a href=&quot;https://kubernetes.io/docs/tasks/tools/install-minikube/&quot;&gt;官方網頁&lt;/a&gt;下載安裝，Windows、Mac、Linux 都可以安裝。&lt;/p&gt;

&lt;p&gt;Windows 需要先安裝 &lt;a href=&quot;https://chocolatey.org/&quot;&gt;Chocolatey&lt;/a&gt; 套件管理工具，接著輸入指令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;choco install minikube
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;即可完成安裝。而 Mac 則可以透過 homebrew 來完成安裝&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew install minikube 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;起步走開始使用-minikube-與-kubectl&quot;&gt;起步走，開始使用 Minikube 與 kubectl&lt;/h2&gt;

&lt;p&gt;安裝完 minikube 之後，第一步先啟動 Minikube，如果你是第一次啟動，Minikube 會幫你建立新的虛擬機器 (VM)。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;minikube start
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;眼尖的你看到最後一行，啟動好 minikube 的同時，kubectl 也準備就緒了。來看看 minikube 的狀態。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;minikube status
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上一篇提到的 kubelet 與 api-server 已經成功跑起來。複習一下 api-server 是 Master 的元件，kubelet，則是 Node 上負責跟 Master 溝通的元件。因為 Minikube 只有單一個 Node，所以同時具備 Master 與 Node 的元件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/0*g0EkSg37jwB0wHNb.png&quot; alt=&quot;&quot; /&gt;
&lt;a href=&quot;https://kubernetes.io/docs/concepts/overview/components/&quot;&gt;ref: https://kubernetes.io/docs/concepts/overview/components/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;使用 kubectl 查看目前 Cluster 中的狀態&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl get all
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;裡面只有一個 kubernetes 的 service，因為我們的 Kubenetes Cluster 中還沒有安裝任何的東西。&lt;/p&gt;

&lt;h2 id=&quot;建立一個-python-的-flask-web-應用程式&quot;&gt;建立一個 Python 的 Flask Web 應用程式&lt;/h2&gt;

&lt;p&gt;建立資料夾名稱為 flask_app&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir flask_app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;建立一個子資料夾 app ，並在之中建立一個 app.py 檔案&lt;/p&gt;

&lt;div class=&quot;language-py highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c1&quot;&gt;# flask_app/app/app.py
&lt;/span&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;flask&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Flask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Hello, World!&quot;&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'__main__'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'0.0.0.0'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;建立 requirement.txt&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# flask_app/app/requirement.txt
Flask
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在本地端試跑，先安裝依賴的套件，目前只有一個就是 flask&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip3 install -r requirements.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;接著執行看看&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python main.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;打開 &lt;a href=&quot;http://0.0.0.0:5000/&quot;&gt;0.0.0.0:5000&lt;/a&gt; 即可看到以下訊息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hello from Python!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;容器化-flask-web-應用程式&quot;&gt;容器化 Flask Web 應用程式&lt;/h2&gt;

&lt;p&gt;建立一個 Dockerfiile，意思是用 Python 3.7 作為基本的容器，並把專案中的程式碼放進去。並在最後執行 python main.py。&lt;/p&gt;

&lt;div class=&quot;language-dockerfile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; python:3.7&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; /app
&lt;span class=&quot;k&quot;&gt;WORKDIR&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; /app&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;ADD&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; ./app /app/&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;RUN &lt;/span&gt;pip &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; requirements.txt

&lt;span class=&quot;k&quot;&gt;EXPOSE&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; 5000&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CMD&lt;/span&gt;&lt;span class=&quot;s&quot;&gt; [&quot;python&quot;, &quot;/app/main.py&quot;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;製作 docker image，並給他一個名稱flask_app&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    docker build . -t flask_app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以成功 build，沒有問題&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*bSSrv5vrsVqBO2xGZbs0qA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;用 docker images 查看剛剛製作的 image&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2140/1*ta80syB_HoOKMwLmSLOdQA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;跑跑看剛剛製作好的 image&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    docker run -p 5001:5000 flask_app
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;打開 &lt;a href=&quot;http://0.0.0.0:5001/&quot;&gt;http://0.0.0.0:5001/&lt;/a&gt; 一樣會看到&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hello from Python!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;到這邊我們已經製作完成 Docker image。接下來就要把它部屬到 Minikube 上。&lt;/p&gt;

&lt;h2 id=&quot;部屬-python-flask-應用程式到-minikube-上&quot;&gt;&lt;strong&gt;部屬 Python Flask 應用程式到 Minikube 上&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;首先我們先來建立一個檔案 k8s.yaml&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
    &lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Service&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;flask-app-service&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;flask-app&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;protocol&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;TCP&quot;&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5000&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;targetPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5000&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;LoadBalancer&lt;/span&gt;
    
    &lt;span class=&quot;s&quot;&gt;---&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apps/v1&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Deployment&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;flask-app&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;matchLabels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;flask-app&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;flask-app&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;flask-app&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;flask_app:latest&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;imagePullPolicy&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Never&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;containerPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5000&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;命令列輸入，即可將 flask_app 部屬至 minikube&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl apply -f k8s.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;部屬完的畫面&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*G45yB7h77nfGQ--OtDgG1A.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接著訪問&lt;/p&gt;

&lt;p&gt;剛剛的 k8s.yaml 只有聲明 deployment 與 service 兩種物件，但卻產生了 3 個 pod，原因就在於，deployment 裡面聲明了需要 3 個 pod，所以會擴展出 3 個。&lt;/p&gt;

&lt;p&gt;輸入以下指令查看暴露出來的 IP&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;minikube service flask-app-service --url
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;訪問 &lt;a href=&quot;http://192.168.64.8:30914&quot;&gt;http://192.168.64.8:30914&lt;/a&gt; 就可以看到 Kubernetes 上的 Flask 伺服器回傳的畫面。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hello from Python!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;剛剛我們撰寫 k8s.yaml 時，Service Type 使用的是 LoadBalancer，所以這可是具有負載均衡能力，並且擁有 3 個 Pod 作為支撐的服務。&lt;/p&gt;

&lt;p&gt;是不是很神奇？今天我們做了三種 Hello from Python，分別是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在本地端運行 Flask 伺服器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在單個 Docker 容器運行 Flask 伺服器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 Kubernetes 中的 Cluster 運行 Flask 伺服器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一步一步的將應用程式，容器化，之後再用 K8S 打造成產品等級的服務。Kubernetes 就是這麼的有趣！&lt;/p&gt;

&lt;p&gt;如果喜歡我寫的文章，歡迎追蹤 本人的帳號 &lt;a href=&quot;https://medium.com/@LukaTw&quot;&gt;@LukaTW&lt;/a&gt; 與 &lt;a href=&quot;https://medium.com/starbugs&quot;&gt;StarBugs Weekly 星巴哥技術週刊&lt;/a&gt; 🙂🙂🙂&lt;/p&gt;</content><author><name>Luka</name></author><category term="Kubernetes" /><category term="Minikube" /><category term="Python" /><category term="Flask" /><summary type="html">Minikube、kubectl 終於派上用場囉</summary></entry><entry><title type="html">Kubernetes 教學 01 - 概念與架構</title><link href="https://lukahuang.com/kubernetes-tutorial-01/" rel="alternate" type="text/html" title="Kubernetes 教學 01 - 概念與架構" /><published>2020-02-11T10:32:00+00:00</published><updated>2020-02-11T10:32:00+00:00</updated><id>https://lukahuang.com/kubernetes-tutorial-01</id><content type="html" xml:base="https://lukahuang.com/kubernetes-tutorial-01/">&lt;h2 id=&quot;為什麼該學-k8s--podnode-是什麼搞的我好亂呀&quot;&gt;為什麼該學 K8S ？ Pod、Node 是什麼？搞的我好亂呀！&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/3840/0*CmyuLdGdOQJLKS5t.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;適合讀者：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;已經會使用 Docker，但是不知道 Kubernetes 是什麼。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;想看看 Kubernetes 到底在幹嘛的人。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;為什麼該用-kubernetes&quot;&gt;為什麼該用 Kubernetes?&lt;/h2&gt;

&lt;p&gt;Kubernetes 中間共有八個字母有點長，所以大家就將他簡稱為 K8S。但使用 K8S 有什麼好處？&lt;/p&gt;

&lt;h3 id=&quot;1-可以更好的運用雲端或是實體資源&quot;&gt;1. 可以更好的運用雲端或是實體資源&lt;/h3&gt;

&lt;p&gt;所有的資源集中成了一個大平台，所以調度上更靈活，以往我們以實體機為單位的方式很沒有效率，要調度資源的時候需要開一台實體機器，或是虛擬機器，都很耗費 CPU、記憶體等等的資源。&lt;/p&gt;

&lt;p&gt;而 K8S 內所有的東西都是容器，可以很快啟動，很快的刪除，並且靈活部屬在 Kubernetes 所擁有的資源上。&lt;/p&gt;

&lt;h3 id=&quot;2-讓一切的基礎設施都寫成程式碼&quot;&gt;2. 讓一切的基礎設施都寫成程式碼&lt;/h3&gt;

&lt;p&gt;應用程式容器化之後，所有需要安裝的套件都會寫成 Dockerfile。這樣在新增或修改的時候，不再像是以前的伺服器是個黑盒子，需要花大量的時間除錯。&lt;/p&gt;

&lt;p&gt;部屬的資源則用 Kubernetes 的描述方式撰寫，要前端服務要開幾台，後端服務要開幾台，要自動擴展？ 沒問題，這些 K8S 都可以輕鬆幫你做到。所以你如果要了解整個基礎設施架構時，可以很快的藉由程式碼來認識。&lt;/p&gt;

&lt;h3 id=&quot;3-可以幫助開發者聚焦開發&quot;&gt;3. 可以幫助開發者聚焦開發&lt;/h3&gt;

&lt;p&gt;減少開發者在基礎設施上花的時間，將硬體統一看做一個大平台，開發者只需要寫應用的描述，其他的 K8S 幫你搞定。例如：有節點當機，會自動生成一個新的節點，以維持服務的穩定。&lt;/p&gt;

&lt;h2 id=&quot;一切從-container-開始&quot;&gt;一切從 Container 開始&lt;/h2&gt;

&lt;p&gt;使用 Kubernetes 之前，你需要把你的服務先容器化，或者用人家包好的 Image 建立。例如：你有一個 Node.js 的應用程式、一個 MySQL 的資料庫，都可以架設在 K8S 上面。&lt;/p&gt;

&lt;p&gt;K8S 提供了豐富的、可以應用於產品環境的一切資源給你。例如：自動擴展、負載均衡、定時工作 … 等等一切你想得到的東西。&lt;/p&gt;

&lt;p&gt;但是在開始使用 K8S 之前，你需要把你的服務先容器化。雖然一開始很痛苦，需要花很多時間做原本不必要做的事情，但是你容器化你的服務之後會發現，以前需要在不知道被做過什麼事情的機器上摸索的體力活，通通都自動化、或是很易於找到解法，因為在程式碼裡面都有跡可尋。&lt;/p&gt;

&lt;h2 id=&quot;理解-nodepodcontainer-之間的關係&quot;&gt;理解 Node、Pod、Container 之間的關係&lt;/h2&gt;

&lt;p&gt;Node 是 K8S 中的一台實體機器、或是雲端上的一台機器，又稱作是工作者。他有個別名叫做奴隸 (minion) ，挺有趣的。&lt;/p&gt;

&lt;p&gt;Pod 是 K8S 中基本的單位，負責裝一個或多個多個 Container (容器)。&lt;/p&gt;

&lt;p&gt;Container 中就是我們容器化好的應用程式，例如：Node.js 應用程式、MySQL 服務 … 等等&lt;/p&gt;

&lt;p&gt;需要 Pod 來作為基本單位的原因是，如果每個 Container 都作為 K8S 的最小單位，那麼管理網路會變得非常的困難。以 Pod 來區隔，同一個 Pod 裡面的 Container 能夠在本地端互相的連線，只有需要提供給外部呼叫的 API 才需要暴露出來。&lt;/p&gt;

&lt;p&gt;示意圖如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*vJp5o7ABILiIapesES8j6g.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;理解-kubernetes-cluster&quot;&gt;理解 Kubernetes Cluster&lt;/h2&gt;

&lt;p&gt;Kubernetes 集群由控制面板 Control Panel 與節點 Node 所組成。控制面板又稱為是 Kubernetes Master。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*J4GBXcAOasRI0aPgd4-IYw.png&quot; alt=&quot;&quot; /&gt;
&lt;a href=&quot;https://kubernetes.io/docs/concepts/overview/components/&quot;&gt;https://kubernetes.io/docs/concepts/overview/components/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;控制面板由幾個元件 (Component) 所組成：&lt;/p&gt;

&lt;h3 id=&quot;1-kube-api-server&quot;&gt;1. Kube API Server&lt;/h3&gt;

&lt;p&gt;控制面板中用來暴露 Kubernetes API 的元件，讓其他服務可以讀寫 K8S 的資源物件 (Resouce Object)。&lt;/p&gt;

&lt;h3 id=&quot;2-kube-schedular&quot;&gt;2. Kube Schedular&lt;/h3&gt;

&lt;p&gt;調度器，需要調度軟體、硬體資源的時候就要靠調度器囉。例如：如果新建立的 pod 沒有 node 可以放的時候，調度器就會開啟一個新的 node，來放置剛剛需要建立的 pod。&lt;/p&gt;

&lt;h3 id=&quot;3-kube-controller-manager&quot;&gt;&lt;strong&gt;3. Kube Controller Manager&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;是一個在背景持續執行的程序 (daemon)，用來調節系統狀態，透過 api-server 可以監視 Cluster 共享的狀態。&lt;/p&gt;

&lt;p&gt;需要變更目前狀態的時候 Kube Controller 就會將目前的狀態變更到想要變更的狀態，例如：本來 2 個副本 (Replica) 擴展到 4 個副本。&lt;/p&gt;

&lt;p&gt;包含了副本控制器 (Replication Controller)，端點控制器 (Endpoint Controller)、命名空間控制器(Namepsace Controller)與服務帳號控制器&lt;/p&gt;

&lt;h3 id=&quot;4-cloud-controller-manager&quot;&gt;&lt;strong&gt;4. Cloud Controller Manager&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;基於 Kube Controller Manager，各個雲平台提供者（Provider）的實作。而每個 Node 則包含：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;kubelet — 用來跟 Master 溝通的元件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;kube-proxy — 網路代理，用來反應 K8S 各個 Node 上的網路服務&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;讀-kubernetes-api-初探-k8s-的資源物件&quot;&gt;讀 Kubernetes API 初探 K8S 的資源物件&lt;/h2&gt;

&lt;p&gt;我們可以透過 Kubernetes API 讀寫 K8S 的資源物件 (Resource Object)，剛剛說的 Kubernetes Cluster 就分為 Kubernetes API 總共分為五大類，分別是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Workload 物件 — 用來「管理或是運行 Container」 在 Cluster 上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;服務發現與負載均衡物件 — 讓 Workload 可以「縫住」形成可被外部存取到的服務，或是有負載均衡能力的服務。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Config 與 Storage 物件 — Config 用來將配置注入你的應用程式中。Storage 讓 Container 的資料可以永久保存在 Container 之外。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cluster 物件 — 用來定義集群本身的物件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Meta 物件 — 用來配置資源之間的行為的物件。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;這種分類法較接近開發者，可以藉此看看開發者在想些什麼。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2880/1*bbG-QtOtZ17CflsIlS7mwA.png&quot; alt=&quot;&quot; /&gt;
&lt;a href=&quot;https://kubernetes.io/docs/reference/#api-reference&quot;&gt;https://kubernetes.io/docs/reference/#api-reference&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;還有精美的 kubectl 範例可以使用，很方便。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*_F_r0Wh9822ZWBc3w3jeLQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;kubectl--跟-k8s-cluster-溝通的工具&quot;&gt;kubectl — 跟 K8S Cluster 溝通的工具&lt;/h2&gt;

&lt;p&gt;我們絕大多數對 K8S 的操作都需要透過 kubectl，kubectl 的是什麼呢？DevOps 開發者用 kubectl 命令列工具，可以透過 Kubernetes Master 上的 api-server 對各個 Node 下達指令。而這些 API 即是上一小節說的 Kubernetes API。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/0*OhlD7-6XRajuS4QZ.png&quot; alt=&quot;&quot; /&gt;
&lt;a href=&quot;https://www.redhat.com/zh/topics/containers/what-is-kubernetes&quot;&gt;https://www.redhat.com/zh/topics/containers/what-is-kubernetes&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;to be continued …&lt;/p&gt;

&lt;p&gt;下一部分會比較偏重實作， Minikube 的基本操作、Kubectl 的基本操作與重要的 資源物件的介紹。&lt;/p&gt;

&lt;p&gt;如果喜歡我寫的文章，歡迎追蹤 本人的帳號 &lt;a href=&quot;https://medium.com/@LukaTw&quot;&gt;@LukaTW&lt;/a&gt; 與 &lt;a href=&quot;https://medium.com/starbugs&quot;&gt;StarBugs Weekly 星巴哥技術週刊&lt;/a&gt; 🙂🙂🙂&lt;/p&gt;</content><author><name>Luka</name></author><category term="Kubernetes" /><category term="Minikube" /><summary type="html">為什麼該學 K8S ？ Pod、Node 是什麼？搞的我好亂呀！</summary></entry><entry><title type="html">從零開始學 DevOps — 那就選擇最簡單的 Drone CI 開始吧！</title><link href="https://lukahuang.com/drone/" rel="alternate" type="text/html" title="從零開始學 DevOps — 那就選擇最簡單的 Drone CI 開始吧！" /><published>2020-01-14T10:32:00+00:00</published><updated>2020-01-14T10:32:00+00:00</updated><id>https://lukahuang.com/drone</id><content type="html" xml:base="https://lukahuang.com/drone/">&lt;h2 id=&quot;從零開始學-devops--那就選擇最簡單的-drone-ci-開始吧&quot;&gt;從零開始學 DevOps — 那就選擇最簡單的 Drone CI 開始吧！&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/10340/0*JN9t3uzpnpf0KCnz&quot; alt=&quot;Photo by [Ivan Diaz](https://unsplash.com/@mdi?utm_source=medium&amp;amp;utm_medium=referral) on [Unsplash](https://unsplash.com?utm_source=medium&amp;amp;utm_medium=referral)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;目前 DevOps 已經是 Backend 或 Frontend 多多少少都會碰到的部份。而 Drone，正可以讓開發者專心開發自己的專案，每個專案獨立設定需要的 CI / CD 流程，解放前端、後端工程師的戰鬥力，將測試與部屬結合在開發流程中，降低手動測試需要的時間。話不多說，趕快開始架設第一個 Drone CI 伺服器吧。&lt;/p&gt;

&lt;p&gt;本篇文章分為兩個部分，第一個部分來聊聊，為什麼從 Jenkins -&amp;gt; CircleCI -&amp;gt; Drone ，的過程。第二部分則是架設 Drone 的教學。&lt;/p&gt;

&lt;h2 id=&quot;為什麼從-jenkins---circleci---drone&quot;&gt;為什麼從 Jenkins -&amp;gt; CircleCI -&amp;gt; Drone&lt;/h2&gt;

&lt;p&gt;第一次接觸 Drone 已經是兩年前，當時的 Drone 是 0.x 版，跟現在的 1.0 版本有不少的差異。那時候玩了一陣子 DroneCI，Docker 化了一些服務，但因為那時對 CI / CD 不甚熟悉，從 Jenkins、DroneCI 與 CircleCI 中選擇。&lt;/p&gt;

&lt;h3 id=&quot;簡單比較-jenkinsdronecicircleci-三套工具&quot;&gt;簡單比較 Jenkins、DroneCI、CircleCI 三套工具&lt;/h3&gt;

&lt;p&gt;Jenkins 複雜度高，可以操作的東西最多。DroneCI 每個步驟都是由 Docker 產生的環境，高度的容器化，讓每個步驟可以調用不同的 Docker Image 來實現各種測試。&lt;/p&gt;

&lt;p&gt;例如：步驟一可以用 nodejs 的 Docker image 測前端的部分，步驟二可以用 golang 的 Docker image 測試後端的框架，然後接著用傳送訊息專用的 Image 傳送 CI / CD 測試結果到 Slack。&lt;/p&gt;

&lt;h3 id=&quot;重新採用-droneci-的原因&quot;&gt;重新採用 DroneCI 的原因&lt;/h3&gt;

&lt;p&gt;這次重新採用 DroneCI 的原因是我們需要大量的 build image，用 CircleCI 來做實在很不划算，因為你用他的雲端空間就是要被吃豆腐。再者，這次已經對 Docker 有很多的熟悉度，也對 CI / CD 流程有更高的理解。&lt;/p&gt;

&lt;p&gt;有一點需要特別說明的是，因為我是 Backend 工程師，所以比較喜歡更開發更貼近的工程師的 DroneCI，每個專案底下都有 .drone.yml，負責不同專案的開發者可以輕鬆設計自己需要的 CI/CD 流程。&lt;/p&gt;

&lt;p&gt;而 Jenkins 還是 DevOps / SRE 的王者，功能性的強大，幾乎無所不能，不過因為我有圖型介面障礙，每次都會忘記在哪邊按，而且想要把任何東西都進版控，所以我當然是選 DroneCI 囉！&lt;/p&gt;

&lt;h3 id=&quot;用-droneci-就是要自己架&quot;&gt;用 DroneCI 就是要自己架&lt;/h3&gt;

&lt;p&gt;DroneCI 經過 1.0 的改版後已經提供了雲端服務 &lt;a href=&quot;https://cloud.drone.io/&quot;&gt;drone cloud&lt;/a&gt;。不過 … 既然都用 Drone 了當然是要自己架！第一種架設方式是開一台機器例如： EC2，在上面安裝好 Docker、Docker Compsoe、然後下載 Drone 的壓縮檔，接著解壓縮， cd 進入資料夾後輸入 docker-compose up，這樣就架設完成囉。&lt;/p&gt;

&lt;p&gt;自己架設的好處是，自己開的機器便宜，不想用的時候還可關掉。如果你可以清晰知道需要的 CI / CD 流程的哪些環節，並且可以快速的實作出來，用 Drone 是完全沒有問題的。&lt;/p&gt;

&lt;h3 id=&quot;用-k8s-架設更好玩&quot;&gt;用 K8S 架設更好玩&lt;/h3&gt;

&lt;p&gt;踏進 K8S 是個不小的門檻，不過 K8S 絕對是個值得投資的技術，各大雲端霸主不管是 AWS、GCP、Azure 紛紛支援 K8S，雖然乍看之下沒有顯著的好處，但是光是把所有架構的轉成程式碼 ( Infrastructure as Code ，Iac) 就是讓企業體質變好，無形中增加了許多未來的彈性與爆發力。&lt;/p&gt;

&lt;p&gt;既然 K8S 是主流，那當然要用 K8S 來架設 Drone 囉。除了開一台機器以外，Drone 對 K8S 的整合度也是很高的，Helm 有著 &lt;a href=&quot;https://hub.helm.sh/&quot;&gt;Helm Hub&lt;/a&gt; ，就像 Docker hub 一樣，你可以在上面找到各式各樣的 Helm Chart 來建置 Drone。建置完成後還可以進入 K8S 中查看 Drone 的各個工作執行的怎麼樣。&lt;/p&gt;

&lt;h2 id=&quot;該怎麼開始使用-drone-&quot;&gt;該怎麼開始使用 Drone ?&lt;/h2&gt;

&lt;p&gt;還是回到最簡單的方法，在本機或是雲端機器上安裝 docker 與 docker-compose，我們用 Github 來做為說明的範例。&lt;/p&gt;

&lt;h3 id=&quot;step-1--安裝-droneci&quot;&gt;Step 1 — 安裝 DroneCI&lt;/h3&gt;

&lt;p&gt;進入&lt;a href=&quot;https://drone.io/&quot;&gt;官網&lt;/a&gt;，點選 Get Started&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2518/1*JeGCj0yZqFzICaBX3q2zqQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;點選 install&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2306/1*y-3jjXLAq18yioLt-8XQaA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;選擇 Github&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2386/1*A_1WUlNDwtMcodmSNL4bCg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;進入之後開始學習安裝方式，第一個步驟可以跳過，從第二個步驟開始，輸入 docker pull drone/drone:1 拉下來最新的 docker image。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*oSWpHROfnuWr2wWGp7V5zg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接著，根據官方的 docker 指令來撰寫 docker-compose 檔案，我已經幫大家寫好了，複製貼上即可，儲存成 docker-compose.yml。&lt;/p&gt;

&lt;p&gt;&amp;lt;iframe src=”https://medium.com/media/a91d32cb40f76295aba401d9e0e74e73” frameborder=0&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/p&gt;

&lt;p&gt;接著輸入 docker-compose up 啟動 drone，此時可用 docker ps -a 看看 container 有沒有正常啟動&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*vUJFccLcZjhD--24pCRm4g.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;step-2--用-ngrok-讓-port-開放-ip-讓外界存取並加上-https&quot;&gt;Step 2 — 用 ngrok 讓 Port 開放 IP 讓外界存取，並加上 https&lt;/h3&gt;

&lt;p&gt;到 &lt;a href=&quot;https://dashboard.ngrok.com/&quot;&gt;ngrok 官網&lt;/a&gt;註冊帳號，不註冊的話過一段時間就會被斷線&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2084/1*RRyhzg7_hptFfU5RZfq1Jg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;註冊完之後會顯示以下畫面，mac 可以使用 brew install ngrok 安裝 ngrok。安裝完後使用下圖箭頭指示處的，複製貼上，在本機登入你的帳號。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2060/1*sJjAvifeYuOlNrxEnkdl4Q.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之後就可以開心的使用 ngrok 綁定端口囉！&lt;/p&gt;

&lt;p&gt;例如在終端機中輸入 ngrok http 8081，就會把剛剛架設的 drone 伺服器 localhost 的 8081 端口綁定到特定的 ngrok 網址。這邊的網址等下需要複製貼上綁定到 Github OAuth App 上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*PuxSJe60XUqpfDBBceZupQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;step-3-github-設定-oauth-app&quot;&gt;Step 3— Github 設定 OAuth App&lt;/h3&gt;

&lt;p&gt;選擇螢幕右上方選單的 Settings&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*7CIiJZbvCKLb5lfsPxN7cg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;進入後選擇左下方的 Developer Settings&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*HdxclQS70dX4FbETCMVxhw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;點選 OAuth Apps&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*UrZn_vFgPmeIceIjjx-4lA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;新增 Oauth 應用程式&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2574/1*Zsvs6JFoMdisHqahhb2ltw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;將剛剛建立好的 ngrok 網址填入，註冊 OAuth 應用程式。這邊雷的地方，Drone 0.8 的 callback 網址是 authorize，1.0 換成 login，文件上沒有特別著名。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*3JAoWcFx4BGsG19w6wkY2w.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;當以上都設定好的時候代表你的 Drone CI 串接完成囉！訪問你的 ngrok 暫時網址，我的是 https://844f00ae.ngrok.io 。還記得 ngrok 是做什麼用的嘛，ngrok 可以讓本地端的端口暴露到網際網路。所以可以在任何地方存取的到。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*UG6pbB8rFnKKctU5lvsnPg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;登入後 drone 已經建立成功囉，紅框的網址可以替代成任何你伺服器上的網址。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2118/1*08dTULm4YIx7v5LFwi_E0Q.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我們來開啟監控一個 drone 的 project，如果這專案有改變就會觸發 CI / CD 流程。大家想要一起玩可以到這邊 fork 專案 &lt;a href=&quot;https://github.com/drone-demos/drone-with-nodejs&quot;&gt;https://github.com/go-training/drone-nodejs-example&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2144/1*TDNbj7nNu4OrTT5VXaaDig.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;開啟後會顯示專案目前是開啟的狀態。只要有 commit push 即可觸發。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/NaN/1*sC8f7JVfEJgKOHCHIqvKxg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;來試試看，加一個 commit 並 push，觸發 Drone CI&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*WhSeytz5KRnnZ8hXvra8nQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;果然成功了！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2106/1*rSC_dLjMghPagl22PQHk6A.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;完成之後&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2040/1*trGae2DEva01LWxk7jxI8Q.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Great！我們做出了第一個 CI / CD 系統，好處有什麼呢？今天篇幅有點長，我們留著下次再講吧 :D 下一篇 Drone CI / CD 我們來聊聊 CI / CD 的常見流程！&lt;/p&gt;

&lt;p&gt;如果喜歡我寫的文章，歡迎追蹤本人帳號 &lt;a href=&quot;https://medium.com/@LukaTw&quot;&gt;@LukaTw&lt;/a&gt; 與 &lt;a href=&quot;https://medium.com/starbugs&quot;&gt;StarBugs Weekly 星巴哥技術週刊&lt;/a&gt;🙂&lt;/p&gt;</content><author><name>Luka</name></author><category term="DevOps" /><category term="DroneCI" /><summary type="html">從零開始學 DevOps — 那就選擇最簡單的 Drone CI 開始吧！</summary></entry><entry><title type="html">用 Harbor 架設 Private Docker Registry</title><link href="https://lukahuang.com/harbor/" rel="alternate" type="text/html" title="用 Harbor 架設 Private Docker Registry" /><published>2019-12-17T10:32:00+00:00</published><updated>2019-12-17T10:32:00+00:00</updated><id>https://lukahuang.com/harbor</id><content type="html" xml:base="https://lukahuang.com/harbor/">&lt;h2 id=&quot;用-harbor-架設一個僅供公司內網存取的-docker-registry&quot;&gt;用 Harbor 架設一個僅供公司內網存取的 Docker Registry&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*zYNBpVXtxGID9rttcSYklQ.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;什麼是-docker-registry-&quot;&gt;什麼是 Docker Registry ？&lt;/h2&gt;

&lt;p&gt;顧名思義就是用來儲存鏡像檔 (Image) 的地方。例如：DockerHub 就是 Docker 官方提供的 Docker Registry，你可以把你自己編寫的 Dockerfile 編譯之後上傳到 Dockerhub ，讓網路上的其他人自由的下載，讓大家站在你的肩膀上寫程式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2402/1*xCluFgOIs4GgoiAFkxIOJg.png&quot; alt=&quot;Dockerhub 首頁&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2328/1*5V65KKaQS5QlDeSEMW6Crg.png&quot; alt=&quot;在 dockerhub 上面可以搜尋到 ubuntu 官方釋出的 docker image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;為什麼要架設私有的-docker-registry&quot;&gt;為什麼要架設私有的 Docker Registry？&lt;/h2&gt;

&lt;p&gt;在這個容器化的時代， 要使用 Kubernetes 生態系，第一步是將原本的實體機器的配置轉換成程式碼，轉換完成後變成 Dockerfile，Dockerfile 編寫著這台機器上所有的配置。&lt;/p&gt;

&lt;p&gt;我們需要找一個地方存放由這些 Dockerfile 建立 (build) 出來的 Docker 鏡像檔，這些鏡像檔總不能放在 Dockerhub 上給大家一覽無遺吧？因此我們需要一個私有的 Docker Registry 來放置建立的 Docker 鏡像檔。&lt;/p&gt;

&lt;h2 id=&quot;harbor-是什麼&quot;&gt;Harbor 是什麼？&lt;/h2&gt;

&lt;p&gt;Harbor 是由 VMware 發行的鏡像檔儲存倉庫，就是你自行架設一個只有公司內部可以存取到的 Dockerhub，公司內部使用的鏡像檔都上傳到上面，要使用時也都從 Harbor 中拉下來 (pull image)。&lt;/p&gt;

&lt;p&gt;Harbor 的管理介面如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/3052/1*pl2f1k9c_PdW_QWxRf1cAQ.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每一個專案可以有多個 Repository，而每個 Repository 可以上傳多個 Image&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/3078/1*l76NWolqE7O0t0rGAafk6A.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;harbor-在-cicd-中扮演的角色&quot;&gt;Harbor 在 CI/CD 中扮演的角色&lt;/h2&gt;

&lt;p&gt;用一張圖表來說明 Docker Registry 在 CI / CD 流程中扮演的角色：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2808/1*M69pOie1Kw6U1G36CC6sVA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先我們把程式碼推上 Github，觸發 CI / CD (以 Jenkins 為例) Pipeline，Pipeline 中包含跑測試、程式碼品質檢測 … 等等的步驟，依照需求自由定義。&lt;/p&gt;

&lt;p&gt;跑完 CI / CD Pipeline 後便會把 Docker Image 推上 Harbor。接著如果 K8S 需要取用時便會從 Harbor 拉取 (pull) 需要的版本的 Image。&lt;/p&gt;

&lt;p&gt;註：更安全的作法是 Github 用私有的程式碼儲存庫取代，這邊為了簡單示意，用 Github 作為程式碼儲存庫的代表。&lt;/p&gt;

&lt;h2 id=&quot;如何架設-harbor&quot;&gt;如何架設 Harbor？&lt;/h2&gt;

&lt;h3 id=&quot;harbor-的安裝方式&quot;&gt;Harbor 的安裝方式&lt;/h3&gt;

&lt;p&gt;在 Github 上面可以看到 Harbor 是 1 萬顆星星以上的大型開源專案&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2260/1*CH1EH9Z67Zb1Ly-yLwq9Kg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;找到 Install &amp;amp;&amp;amp; Run 區域的說明，上面寫著先下載 binary 檔案，然後跟著安裝手冊操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2126/1*B-Q22EUDNzCgm0iMguOZOA.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我們就進入到 &lt;a href=&quot;https://github.com/goharbor/harbor/releases&quot;&gt;Harbor Release&lt;/a&gt; 頁面&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2264/1*ROVmxJmXqeKol5YLfjjN8w.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;往下卷找到 Assets 區域&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2014/1*lNDshHJA-X-ZyF6EG_e_3g.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;這時我們點選 online installler 下載，如果在 linux 主機上可以用 wget 取得。&lt;/p&gt;

&lt;h3 id=&quot;安裝-docker-與-docker-compose&quot;&gt;安裝 Docker 與 Docker Compose&lt;/h3&gt;

&lt;p&gt;接著到 &lt;a href=&quot;https://github.com/goharbor/harbor/blob/master/docs/installation_guide.md&quot;&gt;Harbor Installation and Configuration Guide&lt;/a&gt; 觀看教學逐步完成安裝，安裝 Harbor 時需要安裝 Docker 與 Docker Compose。&lt;/p&gt;

&lt;p&gt;首先我們需要安裝 Docker，用 Ubuntu 18.04 來演練：參考 &lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-18-04&quot;&gt;How To Install and Use Docker on Ubuntu 18.04&lt;/a&gt; 逐步完成 docker 安裝。&lt;/p&gt;

&lt;p&gt;除了需要 Docker 以外，還需要 docker-compose，參考 &lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-install-docker-compose-on-ubuntu-18-04&quot;&gt;How To Install Docker Compose on Ubuntu 18.04&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;繼續安裝-harbor&quot;&gt;繼續安裝 Harbor&lt;/h3&gt;

&lt;p&gt;取得剛剛 release 畫面獲得的安裝包位置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget https://github.com/goharbor/harbor/releases/download/v1.10.0/harbor-online-installer-v1.10.0.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;解壓縮之&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tar xvf harbor-online-installer-v1.10.0.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;現在你有 harbor 安裝檔資料夾&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*oucT344pLoZU6e0MUKr_Cg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;進入 harbor 資料夾，看到有幾個檔案，install.sh 就是安裝檔了，首先我們要先修改 harbor.yml&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*W2KPqrMFv2TC--85ciaIdw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;將 hostname 修改，否則直接運行 install.sh 是會發生錯誤的。除了修改 hostman 以外，修改 admin password 預設管理員密碼，可以增加安全性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn-images-1.medium.com/max/2000/1*jDUzW33Dqar1YOkZWwzgpg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;修改完成後執行 sudo ./install.sh，harbor 需要的服務就會依序被建立起來，就是這麼簡單。&lt;/p&gt;

&lt;p&gt;此時訪問這台機器的 ip 位置，就會出現登入畫面囉！&lt;/p&gt;

&lt;h2 id=&quot;結語&quot;&gt;結語&lt;/h2&gt;

&lt;p&gt;現在你擁有了一個可以放在公司內網的 Docker Registry，你可以在上面自由的上傳自己建立的 Docker Image，不用怕被看光光，是不是很棒呢。&lt;/p&gt;

&lt;p&gt;如果喜歡我寫的文章，歡迎追蹤本人帳號 &lt;a href=&quot;https://medium.com/@LukaTw&quot;&gt;@LukaTw&lt;/a&gt; 與 &lt;a href=&quot;https://medium.com/starbugs&quot;&gt;StarBugs Weekly 星巴哥技術週刊&lt;/a&gt; 🙂🙂🙂&lt;/p&gt;</content><author><name>Luka</name></author><category term="Harbor" /><category term="Docker" /><summary type="html">用 Harbor 架設一個僅供公司內網存取的 Docker Registry</summary></entry></feed>